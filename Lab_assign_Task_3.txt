#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif
#include <iostream>
#include <vector>
#include <string>

struct Line { double x0,y0,x1,y1; };
struct Seg  { double x0,y0,x1,y1; bool valid; };

int winW = 800;
int winH = 600;
double xminw, yminw, xmaxw, ymaxw;
std::vector<Line> orig;
std::vector<Seg> clipped;
bool usingRecommended = false;

bool liangBarsky(double x0, double y0, double x1, double y1, double xmin, double ymin, double xmax, double ymax, double &cx0, double &cy0, double &cx1, double &cy1) {
    double dx = x1 - x0;
    double dy = y1 - y0;
    double p[4] = {-dx, dx, -dy, dy};
    double q[4] = {x0 - xmin, xmax - x0, y0 - ymin, ymax - y0};
    double u1 = 0.0, u2 = 1.0;
    for (int i = 0; i < 4; ++i) {
        if (p[i] == 0) {
            if (q[i] < 0) return false;
        } else {
            double t = q[i] / p[i];
            if (p[i] < 0) {
                if (t > u1) u1 = t;
            } else {
                if (t < u2) u2 = t;
            }
        }
    }
    if (u1 > u2) return false;
    cx0 = x0 + u1 * dx;
    cy0 = y0 + u1 * dy;
    cx1 = x0 + u2 * dx;
    cy1 = y0 + u2 * dy;
    return true;
}

void myInit() {
    glClearColor(0,0,0,1);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, winW, 0, winH);
}

void drawRectangle(double xmin, double ymin, double xmax, double ymax) {
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    glVertex2d(xmin, ymin);
    glVertex2d(xmax, ymin);
    glVertex2d(xmax, ymax);
    glVertex2d(xmin, ymax);
    glEnd();
}

void drawText(int x, int y, const std::string &s) {
    glRasterPos2i(x, y);
    for (char c : s) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, c);
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.2f, 0.6f, 1.0f);
    drawRectangle(xminw, yminw, xmaxw, ymaxw);

    glColor3f(1.0f, 0.3f, 0.3f);
    glLineWidth(1.0f);
    glBegin(GL_LINES);
    for (auto &L : orig) {
        glVertex2d(L.x0, L.y0);
        glVertex2d(L.x1, L.y1);
    }
    glEnd();

    glColor3f(0.4f, 1.0f, 0.4f);
    glLineWidth(3.0f);
    glBegin(GL_LINES);
    for (auto &S : clipped) {
        if (S.valid) {
            glVertex2d(S.x0, S.y0);
            glVertex2d(S.x1, S.y1);
        }
    }
    glEnd();

    glColor3f(1.0f, 1.0f, 1.0f);
    int margin = 10;
    drawText(margin, winH - 20, "Recommended example (press 'y' in console to use):");
    drawText(margin, winH - 36, "Clipping window: 250 200 550 400    Number of lines: 3");
    drawText(margin, winH - 52, "Triangle lines:");
    drawText(margin+10, winH - 68, "100 100 700 100");
    drawText(margin+10, winH - 84, "700 100 400 500");
    drawText(margin+10, winH -100, "400 500 100 100");

    if (usingRecommended) {
        drawText(margin, margin + 10, "Using recommended example.");
    } else {
        drawText(margin, margin + 10, "Using custom input.");
    }

    glFlush();
}

int main(int argc, char** argv) {
    std::cout << "Liang-Barsky Line Clipping\n";
    std::cout << "Window coordinate system: X in [0," << winW << "], Y in [0," << winH << "]\n\n";
    std::cout << "Recommended example (centered clipping window + triangle):\n";
    std::cout << "Clipping window: 250 200 550 400\n";
    std::cout << "Number of line segments: 3\n";
    std::cout << "Line segments:\n";
    std::cout << "  100 100 700 100\n";
    std::cout << "  700 100 400 500\n";
    std::cout << "  400 500 100 100\n\n";
    std::cout << "To use the recommended example type 'y' and press Enter. To enter your own data type 'n' and press Enter: ";

    char choice = 'n';
    if (!(std::cin >> choice)) return 0;
    if (choice == 'y' || choice == 'Y') {
        usingRecommended = true;
        xminw = 250; yminw = 200; xmaxw = 550; ymaxw = 400;
        orig.clear();
        clipped.clear();
        Line L1 = {100,100,700,100};
        Line L2 = {700,100,400,500};
        Line L3 = {400,500,100,100};
        orig.push_back(L1); orig.push_back(L2); orig.push_back(L3);
        clipped.resize(3);
        for (size_t i=0;i<orig.size();++i) {
            double cx0,cy0,cx1,cy1;
            if (liangBarsky(orig[i].x0, orig[i].y0, orig[i].x1, orig[i].y1, xminw, yminw, xmaxw, ymaxw, cx0, cy0, cx1, cy1)) {
                clipped[i].x0 = cx0; clipped[i].y0 = cy0; clipped[i].x1 = cx1; clipped[i].y1 = cy1; clipped[i].valid = true;
            } else {
                clipped[i].valid = false;
            }
        }
    } else {
        usingRecommended = false;
        std::cout << "Enter clipping window as: xmin ymin xmax ymax (numbers separated by space): ";
        if (!(std::cin >> xminw >> yminw >> xmaxw >> ymaxw)) return 0;
        if (xminw > xmaxw) std::swap(xminw, xmaxw);
        if (yminw > ymaxw) std::swap(yminw, ymaxw);
        int n;
        std::cout << "Enter number of line segments: ";
        if (!(std::cin >> n)) return 0;
        if (n <= 0) return 0;
        orig.clear();
        clipped.clear();
        orig.reserve(n);
        clipped.resize(n);
        std::cout << "For each line enter: x0 y0 x1 y1 (endpoints separated by space). Coordinates may be outside clipping window.\n";
        for (int i = 0; i < n; ++i) {
            Line L;
            std::cout << "Line " << i+1 << ": ";
            if (!(std::cin >> L.x0 >> L.y0 >> L.x1 >> L.y1)) return 0;
            orig.push_back(L);
            double cx0,cy0,cx1,cy1;
            if (liangBarsky(L.x0, L.y0, L.x1, L.y1, xminw, yminw, xmaxw, ymaxw, cx0, cy0, cx1, cy1)) {
                clipped[i].x0 = cx0; clipped[i].y0 = cy0; clipped[i].x1 = cx1; clipped[i].y1 = cy1; clipped[i].valid = true;
            } else {
                clipped[i].valid = false;
            }
        }
    }

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(winW, winH);
    glutInitWindowPosition(200, 100);
    glutCreateWindow("Liang-Barsky Line Clipping (recommended input visible)");
    myInit();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}
